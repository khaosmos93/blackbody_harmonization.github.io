<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blackbody Harmonization</title>
<style>
  :root { --b:#333; --t:#fff; --mut:#aaa; --panel:rgba(0,0,0,.6); --accent:#00d1ff; --accent2:#ff4d4f; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  html, body { height:100%; }
  body { margin:0; color:var(--t); background:#000; overflow:hidden; }
  /* use dynamic viewport height to avoid mobile chrome/safari UI cropping */
  #stage { position:relative; width:100vw; height:100dvh; overflow:hidden; background:#000; }
  #imgCanvas, #drawCanvas {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    display:block; max-width:100vw; max-height:100dvh; width:auto; height:auto;
  }
  #drawCanvas { pointer-events:auto; }

  /* Responsive toolbar positioning (safe-area aware) */
  #toolbar {
    position:absolute; left:12px; top:calc(env(safe-area-inset-top) + 52px); z-index:9999;
    background:var(--panel); border:1px solid var(--b); border-radius:12px; padding:10px; backdrop-filter: blur(6px);
    max-width:min(92vw, 560px);
    /* keep inside viewport with dynamic height budget */
    max-height: calc(100dvh - (env(safe-area-inset-top) + 24px) - 16px);
    overflow: auto; -webkit-overflow-scrolling: touch;
  }

  /* Toggle anchored to the same top safe-area so it doesn't crop */
  #toggle { position:absolute; left:12px; top:calc(env(safe-area-inset-top) + 12px); z-index:10000; border:none; border-radius:999px; padding:10px 12px; background:var(--panel); color:#fff; cursor:pointer; backdrop-filter: blur(6px); }
  #toggle small { opacity:.8; }
  #toolbar[hidden]{ display:none; }
  #status { pointer-events: auto; }
  .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .col { display:flex; flex-direction:column; gap:8px; }
  label { display:inline-flex; align-items:center; gap:6px; }
  input[type="number"], select { background:#111; color:#fff; border:1px solid #444; border-radius:8px; padding:4px 6px; }
  input[type="range"] { width:140px; }
  button { padding:8px 12px; border-radius:10px; border:1px solid #444; background:#111; color:#fff; cursor:pointer; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .pill { display:inline-block; padding:2px 8px; border:1px solid #444; border-radius:999px; background:#111; }
  .muted { color:var(--mut); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .chip { border:1px dashed #444; padding:4px 8px; border-radius:10px; }
  .badge { font-size:12px; padding:2px 6px; border-radius:6px; background:#111; border:1px solid #444; }
  @media (max-width:600px){ #toolbar{ max-width:94vw; } input[type="range"]{ width:110px; } }
</style>
</head>
<body>
  <button id="toggle" aria-expanded="true">☰</button>

  <div id="stage">
    <canvas id="imgCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>

    <div id="toolbar">
      <div class="row" style="margin-bottom:6px">
        <strong>Blackbody Harmonization</strong>
        <span class="pill mono" id="dim">—</span>
        <span class="pill mono">Pixels/sec: <span id="ppsVal">3</span></span>
        <!-- status is now a button (clickable on mobile) with extra hint -->
        <button id="status" type="button" class="pill mono">Enable sound</button>
        <span class="muted mono" style="white-space:nowrap;">(Check mute switch / volume if you don’t hear sound)</span>
      </div>

      <div class="col" style="gap:10px">
        <!-- Live Instrument -->
        <div class="row">
          <label><input type="checkbox" id="live" checked> Live mode (play under cursor)</label>
          <label>Brush(px) <input id="brush" type="number" min="0" max="50" value="2" style="width:70px"></label>
          <label><input type="checkbox" id="sustain" checked> Sustain</label>
          <span class="muted mono">Tip: press harder on stylus/touch for louder notes</span>
        </div>

        <!-- 1) Load -->
        <div class="row">
          <label class="pill">Load image <input type="file" id="file" accept="image/*"></label>
          <span id="imgInfo" class="muted mono">—</span>
        </div>

        <!-- 2) Draw tools -->
        <div class="row">
          <label><input type="radio" name="tool" value="path" checked> Path</label>
          <label><input type="radio" name="tool" value="dot"> Dots</label>
          <label>Step(px) <input id="pathStep" type="number" min="1" max="20" value="2" style="width:64px"></label>
          <span class="chip">Shift+drag to erase path</span>
        </div>
        <div class="row">
          <button id="clearPath">Clear Path</button>
          <button id="clearDots">Clear Dots</button>
          <span class="muted">Playback source:
            <label><input type="radio" name="source" value="path" checked> Path</label>
            <label><input type="radio" name="source" value="dots"> Dots</label>
          </span>
        </div>

        <!-- 3) Scale & audio -->
        <div class="row">
          <label>Key
            <select id="key">
              <option>C</option><option>C#</option><option>D</option><option>D#</option>
              <option>E</option><option>F</option><option>F#</option><option>G</option>
              <option>G#</option><option>A</option><option>A#</option><option>B</option>
            </select>
          </label>
          <label>Scale
            <select id="scale">
              <option value="major">Major</option>
              <option value="natural_minor">Natural minor</option>
              <option value="blues_minor">Blues (minor)</option>
              <option value="pentatonic_major">Pentatonic major</option>
              <option value="pentatonic_minor">Pentatonic minor</option>
              <option value="dorian">Dorian</option>
              <option value="mixolydian">Mixolydian</option>
            </select>
          </label>
          <label>Base <input id="baseOct" type="number" min="1" max="7" value="3" style="width:56px"></label>
          <label>Oct <input id="octaves" type="number" min="1" max="8" value="4" style="width:56px"></label>
        </div>
        <div class="row">
          <label>Pixels/sec <input id="pps" type="range" min="1" max="60" value="3"></label>
          <label>Gain <input id="gain" type="range" min="0" max="1" step="0.01" value="0.25"><span id="gainVal" class="mono">0.25</span></label>
          <label>Length(ms) <input id="ms" type="number" min="20" max="800" value="120" style="width:72px"></label>
        </div>
        <div class="row">
          <label>Harmonics 1× <input id="mix1" type="range" min="0" max="1" step="0.01" value="1"><span id="m1" class="mono">1.00</span></label>
          <label>2× <input id="mix2" type="range" min="0" max="1" step="0.01" value="0.35"><span id="m2" class="mono">0.35</span></label>
          <label>3× <input id="mix3" type="range" min="0" max="1" step="0.01" value="0.2"><span id="m3" class="mono">0.20</span></label>
        </div>
        <div class="row">
          <label>Detune R <input id="detR" type="number" value="0" style="width:64px"></label>
          <label>G <input id="detG" type="number" value="0" style="width:64px"></label>
          <label>B <input id="detB" type="number" value="0" style="width:64px"></label>
        </div>

        <!-- 4) Controls & debug -->
        <div class="row">
          <button id="makeArray" disabled>Make 3×N array</button>
          <button id="play" disabled>Play Path/Dots</button>
          <button id="stop" disabled>Stop</button>
          <button id="download" disabled>Download .json</button>
          <!-- removed old status span from here -->
        </div>
        <div class="row">
          <span class="badge">Array: <span id="arrLen">—</span></span>
          <span class="badge">Path: <span id="pathCount">0</span></span>
          <span class="badge">Dots: <span id="dotCount">0</span></span>
          <span class="muted">Preview: <span class="mono" id="preview">—</span></span>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===== Toolbar toggle ===== */
const toolbar = document.getElementById('toolbar');
const toggleBtn = document.getElementById('toggle');
let open = true;
toggleBtn.addEventListener('click', ()=>{
  open = !open; toolbar.hidden = !open;
  toggleBtn.setAttribute('aria-expanded', String(open));
  toggleBtn.innerHTML = open ? '☰' : '☷ <small>show</small>';
});

/* ===== DOM helpers ===== */
const $ = id => document.getElementById(id);

/* ===== Canvases ===== */
const imgCanvas = $('imgCanvas');
const imgCtx = imgCanvas.getContext('2d', { willReadFrequently: true });
const drawCanvas = $('drawCanvas');
const drawCtx = drawCanvas.getContext('2d');

let imgW=0, imgH=0, arrRGB=null, imageData=null;
let pathPts=[], dots=[], drawing=false, lastPt=null, tool='path';

function setCanvasIntrinsicSize(w,h){
  imgCanvas.width=w; imgCanvas.height=h;
  drawCanvas.width=w; drawCanvas.height=h;
}

function toImageXY(e, canvas){
  const r = canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  const x = (e.clientX - r.left) * scaleX;
  const y = (e.clientY - r.top) * scaleY;
  return [Math.max(0, Math.min(canvas.width-1, x)), Math.max(0, Math.min(canvas.height-1, y))];
}

function redrawOverlay() {
  drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  if (pathPts.length > 1) {
    drawCtx.lineWidth = 5; drawCtx.strokeStyle = '#00d1ff';
    drawCtx.beginPath(); drawCtx.moveTo(pathPts[0][0], pathPts[0][1]);
    for (let i=1;i<pathPts.length;i++) drawCtx.lineTo(pathPts[i][0], pathPts[i][1]);
    drawCtx.stroke();
  }
  drawCtx.fillStyle = '#00d1ff';
  dots.forEach(([x,y])=>{ drawCtx.beginPath(); drawCtx.arc(x, y, 20, 0, Math.PI*2); drawCtx.fill(); });
}

/* ===== Image load ===== */
$('file').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  const img = new Image(); img.src = URL.createObjectURL(f); await img.decode();
  imgW = img.naturalWidth; imgH = img.naturalHeight;
  setCanvasIntrinsicSize(imgW, imgH);
  imgCtx.drawImage(img, 0, 0, imgW, imgH);
  imageData = imgCtx.getImageData(0,0,imgW,imgH);
  $('imgInfo').textContent = f.name; $('dim').textContent = `${imgW}×${imgH}px`;
  $('makeArray').disabled = false; $('play').disabled = false; $('download').disabled = true;
  pathPts = []; dots = []; redrawOverlay(); $('pathCount').textContent='0'; $('dotCount').textContent='0'; $('status').textContent='Enable sound';
});

/* ===== Tools ===== */
document.querySelectorAll('input[name="tool"]').forEach(r => r.addEventListener('change', ()=> tool = r.value));

drawCanvas.addEventListener('pointerdown', e=>{
  if (!imgW) return;
  drawCanvas.setPointerCapture(e.pointerId);
  const [x,y] = toImageXY(e, drawCanvas);
  if (tool === 'path') { drawing = true; lastPt=[x,y]; pathPts.push([x,y]); $('pathCount').textContent=String(pathPts.length); redrawOverlay(); }
  else { dots.push([x,y]); $('dotCount').textContent=String(dots.length); redrawOverlay(); }
});

drawCanvas.addEventListener('pointermove', e=>{
  if (!imgW) return;
  if (e.shiftKey && tool==='path') {
    const [x,y] = toImageXY(e, drawCanvas);
    const rad = 20; pathPts = pathPts.filter(([px,py]) => Math.hypot(px-x, py-y) > rad);
    $('pathCount').textContent = String(pathPts.length); redrawOverlay(); return;
  }
  if (!drawing || tool!=='path') return;
  const [x,y] = toImageXY(e, drawCanvas);
  const step = Number($('pathStep').value)||2;
  const [lx,ly] = lastPt; const dx = x-lx, dy = y-ly; const dist = Math.hypot(dx,dy);
  if (dist >= step) {
    const n = Math.floor(dist / step);
    for (let i=1;i<=n;i++) { const px=lx+dx*(i/n), py=ly+dy*(i/n); pathPts.push([px,py]); }
    lastPt=[x,y]; $('pathCount').textContent=String(pathPts.length); redrawOverlay();
  }
});

['pointerup','pointercancel','pointerleave'].forEach(ev=>{
  drawCanvas.addEventListener(ev, e=>{ drawCanvas.releasePointerCapture?.(e.pointerId); drawing=false; lastPt=null; });
});

$('clearPath').addEventListener('click', ()=>{ pathPts=[]; $('pathCount').textContent='0'; redrawOverlay(); });
$('clearDots').addEventListener('click', ()=>{ dots=[]; $('dotCount').textContent='0'; redrawOverlay(); });

/* ===== Full 3×N array (optional export) ===== */
$('makeArray').addEventListener('click', ()=>{
  if (!imgW) return;
  const data=imageData.data, N=imgW*imgH, out=new Uint8Array(3*N); let k=0;
  for (let i=0;i<data.length;i+=4){ out[k++]=data[i]; out[k++]=data[i+1]; out[k++]=data[i+2]; }
  arrRGB=out; $('arrLen').textContent=`${out.length} (3 × ${N})`; $('preview').textContent=Array.from(out.slice(0,48)).join(', '); $('download').disabled=false; $('status').textContent='Enable sound';
});
$('download').addEventListener('click', ()=>{ if (!arrRGB) return; const blob=new Blob([JSON.stringify(Array.from(arrRGB))],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='rgb_array_3xN.json'; a.click(); });

/* ===== Scale & Audio ===== */
const ROOTS={'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
const SCALES={ major:[0,2,4,5,7,9,11], natural_minor:[0,2,3,5,7,8,10], dorian:[0,2,3,5,7,9,10], mixolydian:[0,2,4,5,7,9,10], pentatonic_major:[0,2,4,7,9], pentatonic_minor:[0,3,5,7,10], blues_minor:[0,3,5,6,7,10] };
function buildScaleMidi(rootName, scaleName, baseOct=3, octaves=4){ const root=ROOTS[rootName]??0, deg=SCALES[scaleName]??SCALES.major; const notes=[]; for(let o=0;o<octaves;o++){ const base=(baseOct+o)*12; for(const d of deg) notes.push(base+root+d); } return notes; }
function valueToMidi(v, list){ const idx=Math.floor((v/256)*list.length); return list[Math.min(idx,list.length-1)]; }
const midiToFreq=m=>440*Math.pow(2,(m-69)/12);

/* UI mirrors */
const ppsEl=$('pps'), ppsVal=$('ppsVal'); ppsEl.oninput=()=>ppsVal.textContent=ppsEl.value;
const gainEl=$('gain'), gainVal=$('gainVal'); gainEl.oninput=()=>gainVal.textContent=(+gainEl.value).toFixed(2);
const mix1=$('mix1'), mix2=$('mix2'), mix3=$('mix3'); const m1=$('m1'), m2=$('m2'), m3=$('m3');
[mix1,mix2,mix3].forEach(sl=>sl.addEventListener('input',()=>{ m1.textContent=(+mix1.value).toFixed(2); m2.textContent=(+mix2.value).toFixed(2); m3.textContent=(+mix3.value).toFixed(2);} ));

/* ===== WebAudio unlock for mobile ===== */
let ac=null, master=null, playing=false, timer=null, seq=[], seqIdx=0;

async function unlockAudio() {
  if (!ac) {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    ac = new Ctx();
    master = ac.createGain();
    master.gain.value = +gainEl.value;
    
    // master.connect(ac.destination);
    const hp = ac.createBiquadFilter();         // removes DC / subsonic junk
    hp.type = 'highpass';
    hp.frequency.value = 30;

    const comp = ac.createDynamicsCompressor(); // tames overlapping bursts
    comp.threshold.value = -24;
    comp.knee.value = 30;
    comp.ratio.value = 12;
    comp.attack.value = 0.003;
    comp.release.value = 0.25;

    master.connect(hp).connect(comp).connect(ac.destination);
  }
  try {
    const silent = ac.createBuffer(1, 1, ac.sampleRate);
    const src = ac.createBufferSource();
    src.buffer = silent;
    src.connect(master);
    src.start(0);
  } catch (_) {}
  if (ac.state === 'suspended' || ac.state === 'interrupted') {
    try { await ac.resume(); } catch (_) {}
  }
}

function ensureAudio() {
  if (!ac) return;
  if (ac.state === 'suspended' || ac.state === 'interrupted') {
    ac.resume()?.catch(()=>{});
  }
}

// Strong unlock: fire multiple audible nodes in the same gesture
function hardUnlockBeep() {
  if (!ac || !master) return;
  const t = ac.currentTime + 0.01;

  // 1) Oscillator blip
  {
    const osc = ac.createOscillator();
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.25, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0008, t + 0.20);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(660, t);
    osc.connect(g).connect(master);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  // 2) 1-frame non-zero buffer
  {
    const buf = ac.createBuffer(1, 2048, ac.sampleRate);
    const ch = buf.getChannelData(0);
    for (let i = 0; i < ch.length; i++) ch[i] = Math.sin(2 * Math.PI * 440 * (i / ac.sampleRate)) * 0.1;
    const src = ac.createBufferSource();
    src.buffer = buf;
    src.connect(master);
    src.start(t + 0.02);
    src.stop(t + 0.07);
  }

  // 3) ConstantSource short tick
  {
    const cs = new (window.ConstantSourceNode || function(ctx){ const o=ctx.createOscillator(); o.frequency.value=0; return o; })(ac);
    const g2 = ac.createGain();
    g2.gain.setValueAtTime(0.0001, t);
    g2.gain.linearRampToValueAtTime(0.15, t + 0.01);
    g2.gain.exponentialRampToValueAtTime(0.0008, t + 0.05);
    (cs.offset || { setValueAtTime: ()=>{} }).setValueAtTime?.(1, t);
    cs.connect(g2).connect(master);
    cs.start?.(t + 0.01);
    cs.stop?.(t + 0.06);
  }
}

function testBeep() {
  if (!ac || !master) return;
  const t = ac.currentTime + 0.01;
  const osc = ac.createOscillator();
  const g = ac.createGain();
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(0.2, t + 0.02);
  g.gain.exponentialRampToValueAtTime(0.0008, t + 0.25);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(440, t);
  osc.connect(g).connect(master);
  osc.start(t);
  osc.stop(t + 0.3);
}


// status button behavior (synchronous unlock in same gesture)
const statusEl = document.getElementById('status');
if (statusEl) statusEl.textContent = 'Enable sound';

// NOTE: no async/await inside this function to keep user gesture intact
function doEnableSoundStrong() {
  try {
    // Create context synchronously if needed
    if (!ac) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      ac = new Ctx();
      master = ac.createGain();
      master.gain.value = +gainEl.value || 0.25;

      // master.connect(ac.destination);
      const hp = ac.createBiquadFilter();         // removes DC / subsonic junk
      hp.type = 'highpass';
      hp.frequency.value = 30;

      const comp = ac.createDynamicsCompressor(); // tames overlapping bursts
      comp.threshold.value = -24;
      comp.knee.value = 30;
      comp.ratio.value = 12;
      comp.attack.value = 0.003;
      comp.release.value = 0.25;

      master.connect(hp).connect(comp).connect(ac.destination);
    }

    // Start an immediate, audible blip *before* any Promise microtask
    const now = ac.currentTime;
    const osc = ac.createOscillator();
    const g   = ac.createGain();
    osc.type = 'sine';
    osc.frequency.value = 1000; // very audible on phone speakers
    g.gain.setValueAtTime(0.001, now);
    g.gain.linearRampToValueAtTime(0.5,  now + 0.03);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    osc.connect(g).connect(master);
    osc.start(now);
    osc.stop(now + 0.45);

    // Also fire the multi-probe unlock immediately
    hardUnlockBeep();

    // Try resume, but don't await it here
    ac.resume && ac.resume().catch(()=>{});

    statusEl.textContent = (ac && ac.state) ? `Audio ready (${ac.state})` : 'Audio ready';
    statusEl.disabled = true;
  } catch (err) {
    statusEl.textContent = 'Enable failed';
    console.error('Audio unlock error:', err);
  }
}

statusEl?.addEventListener('click', doEnableSoundStrong);
statusEl?.addEventListener('touchstart', (e) => {
  e.preventDefault();
  doEnableSoundStrong();
}, { passive: false });
statusEl?.addEventListener('touchend', (e) => {
  e.preventDefault();
  doEnableSoundStrong();
}, { passive: false });

// (Removed the old global one-time auto-unlock to avoid stealing the first tap)

document.addEventListener('visibilitychange', async () => {
  if (!ac) return;
  if (document.visibilityState === 'visible' && (ac.state === 'suspended' || ac.state === 'interrupted')) {
    try { await ac.resume(); } catch (_) {}
  }
});

gainEl.addEventListener('input', ()=>{ if(master) master.gain.value=+gainEl.value; });

function getRGBat(x,y){
  const ix=Math.max(0,Math.min(imgW-1,Math.round(x)));
  const iy=Math.max(0,Math.min(imgH-1,Math.round(y)));
  const idx=(iy*imgW+ix)*4; const d=imageData.data;
  return [d[idx], d[idx+1], d[idx+2]];
}

function getAveragedRGB(cx,cy,r){
  if (r<=0) return getRGBat(cx,cy);
  const xmin=Math.max(0, Math.floor(cx-r)), xmax=Math.min(imgW-1, Math.ceil(cx+r));
  const ymin=Math.max(0, Math.floor(cy-r)), ymax=Math.min(imgH-1, Math.ceil(cy+r));
  let rr=0, gg=0, bb=0, count=0;
  const r2=r*r;
  for(let y=ymin;y<=ymax;y++){
    const dy=y-cy; for(let x=xmin;x<=xmax;x++){
      const dx=x-cx; if (dx*dx+dy*dy>r2) continue;
      const idx=(y*imgW+x)*4, d=imageData.data;
      rr+=d[idx]; gg+=d[idx+1]; bb+=d[idx+2]; count++;
    }
  }
  if (!count) return getRGBat(cx,cy);
  return [Math.round(rr/count), Math.round(gg/count), Math.round(bb/count)];
}

/* Play a pixel (triad, with partials). velocity 0..1 scales envelope */
function playPixelNow(x,y, velocity=1){
  if (!imageData) return;
  ensureAudio();
  const key=$('key').value, scale=$('scale').value;
  const baseOct=parseInt($('baseOct').value||'3',10);
  const octaves=parseInt($('octaves').value||'4',10);
  const midiList=buildScaleMidi(key, scale, baseOct, octaves);
  const [r,g,b] = getAveragedRGB(x,y, Number($('brush').value)||0);
  const mids=[valueToMidi(r,midiList), valueToMidi(g,midiList), valueToMidi(b,midiList)];
  const dur=Math.max(0.02, Math.min(0.8, (+$('ms').value||120)/1000));
  const dets=[parseFloat($('detR').value||'0'), parseFloat($('detG').value||'0'), parseFloat($('detB').value||'0')];
  const t=ac.currentTime + 0.005;

  const env=ac.createGain(); const sus=$('sustain').checked;
  const peak = Math.max(0.02, Math.min(1, velocity)) ;

  // env.gain.setValueAtTime(0, t);
  // env.gain.linearRampToValueAtTime(peak, t+0.01);
  // if (sus){ env.gain.setValueAtTime(peak, t+dur); } else { env.gain.exponentialRampToValueAtTime(0.001, t+dur); }
  // env.connect(master);
  const attack = 0.02;                      // ~20ms = clickless but still snappy
  const offFloor = 0.001;                   // never ramp to true zero (iOS denormal-safe)
  env.gain.setValueAtTime(0, t);
  env.gain.linearRampToValueAtTime(peak, t + attack);
  if (sus) {
    // hold at peak; release will be managed by sustain off / voice stop
    env.gain.setValueAtTime(peak, t + attack + Math.max(0, dur - attack));
  } else {
    // short, smooth tail to avoid hard cut
    env.gain.exponentialRampToValueAtTime(offFloor, t + Math.max(dur, attack + 0.02));
  }
  env.connect(master);

  const parts=[[1,+mix1.value],[2,+mix2.value],[3,+mix3.value]];
  mids.forEach((m,i)=>{
    const baseF=midiToFreq(m);
    parts.forEach(([mul,g])=>{
      if (g<=0) return;
      const f=baseF*mul; if (f >= ac.sampleRate/2-100) return;
      const osc=ac.createOscillator(); osc.type='sine';
      osc.frequency.setValueAtTime(f, t); osc.detune.setValueAtTime(dets[i]||0, t);
      const gNode=ac.createGain(); gNode.gain.value=g;
      osc.connect(gNode).connect(env);
      osc.start(t); osc.stop(t + (sus? Math.max(dur,0.4): dur) + 0.03);
    });
  });
}

/* ===== Live Instrument mode ===== */
const liveChk = $('live');
let liveArmed = false;
let lastLiveTime = 0;
drawCanvas.addEventListener('pointerdown', async (e)=>{
  if (!imageData) return;
  if (!liveChk.checked) return; // only in live mode
  await unlockAudio();
  ensureAudio();
  liveArmed = true;
  const [x,y]=toImageXY(e, drawCanvas);
  const v = e.pressure ? Math.min(1, Math.max(0.05, e.pressure)) : 1;
  playPixelNow(x,y,v);
});
drawCanvas.addEventListener('pointermove', (e)=>{
  if (!imageData || !liveChk.checked || !liveArmed) return;
  const now = performance.now();
  const pps = Math.max(1, parseInt($('pps').value||'12',10));
  const intervalMs = 1000/pps;
  if (now - lastLiveTime < intervalMs) return;
  lastLiveTime = now;
  const [x,y]=toImageXY(e, drawCanvas);
  const v = e.pressure ? Math.min(1, Math.max(0.05, e.pressure)) : 1;
  playPixelNow(x,y,v);
});
['pointerup','pointercancel','pointerleave'].forEach(ev=>{
  drawCanvas.addEventListener(ev, ()=>{ liveArmed = false; });
});

/* ===== Path/Dots sequencer (unchanged logic; mobile-safe unlock) ===== */
function buildSequence(){ const src=document.querySelector('input[name="source"]:checked').value; return src==='path'? pathPts.slice() : dots.slice(); }

function drawCursor(pt){
  redrawOverlay();
  if (!pt) return;
  drawCtx.strokeStyle = '#ffd400';
  drawCtx.lineWidth = 4;
  drawCtx.beginPath();
  drawCtx.arc(pt[0], pt[1], 20, 0, Math.PI*2);
  drawCtx.stroke();
}

$('play').addEventListener('click', async ()=>{
  if (!imageData) return;
  const srcSeq=buildSequence(); if (!srcSeq.length){ $('status').textContent='Enable sound'; return; }
  await unlockAudio();
  ensureAudio();
  playing=true; let seqIdx=0; $('stop').disabled=false; $('play').disabled=true; $('status').textContent='Playing…';

  const key=$('key').value, scale=$('scale').value;
  const baseOct=parseInt($('baseOct').value||'3',10);
  const octaves=parseInt($('octaves').value||'4',10);
  const midiList=buildScaleMidi(key, scale, baseOct, octaves);

  const pps=parseInt($('pps').value,10), stepSec=1/pps;
  const noteMs=Math.max(20, Math.min(800, parseInt($('ms').value||'120',10)));
  const noteDur=Math.min(stepSec*0.95, noteMs/1000);
  const dets=[parseFloat($('detR').value||'0'), parseFloat($('detG').value||'0'), parseFloat($('detB').value||'0')];
  const lookahead=0.1, ahead=0.25;
  let nextTime=ac.currentTime+0.05;

  function schedulePixelChord(time, r,g,b){
    const mids=[valueToMidi(r,midiList), valueToMidi(g,midiList), valueToMidi(b,midiList)];
    const env=ac.createGain(); env.gain.setValueAtTime(0,time); env.gain.linearRampToValueAtTime(1,time+0.01); env.gain.exponentialRampToValueAtTime(0.001,time+noteDur); env.connect(master);
    const parts=[[1,+mix1.value],[2,+mix2.value],[3,+mix3.value]];
    mids.forEach((m,i)=>{
      const baseF=midiToFreq(m);
      parts.forEach(([mul,g])=>{
        if (g<=0) return; const f=baseF*mul; if (f >= ac.sampleRate/2-100) return;
        const osc=ac.createOscillator(); osc.type='sine'; osc.frequency.setValueAtTime(f,time); osc.detune.setValueAtTime(dets[i]||0,time);
        const gNode=ac.createGain(); gNode.gain.value=g; osc.connect(gNode).connect(env); osc.start(time); osc.stop(time+noteDur+0.02);
      });
    });
  }

  function loop(){
    if (!playing) return;
    while (nextTime < ac.currentTime + ahead) {
      if (seqIdx >= srcSeq.length){ stopPlayback(); return; }
      const [x,y]=srcSeq[seqIdx];
      const [r,g,b]=getRGBat(x,y);
      schedulePixelChord(nextTime, r,g,b);
      drawCursor([x,y]);
      seqIdx++; nextTime += stepSec;
    }
    timer = setTimeout(loop, lookahead*1000);
  }
  loop();
});

function stopPlayback(){
  playing=false; if (timer) clearTimeout(timer);
  $('status').textContent='Enable sound'; $('play').disabled=false; $('stop').disabled=true; drawCursor(null);
}
$('stop').addEventListener('click', stopPlayback);
</script>
</body>
</html>

<script>
// === Default image loader (uses the same steps as the file input) ===
async function loadDefaultImage(src){
  try {
    const img = new Image();
    img.src = src;                 // e.g., 'default.jpg' in the same folder
    await img.decode();

    // mirror your file-change logic
    imgW = img.naturalWidth; imgH = img.naturalHeight;
    setCanvasIntrinsicSize(imgW, imgH);
    imgCtx.drawImage(img, 0, 0, imgW, imgH);
    imageData = imgCtx.getImageData(0,0,imgW,imgH);
    $('imgInfo').textContent = src.split('/').pop();
    $('dim').textContent = `${imgW}×${imgH}px`;
    $('makeArray').disabled = false; $('play').disabled = false; $('download').disabled = true;
    pathPts = []; dots = []; redrawOverlay(); $('pathCount').textContent='0'; $('dotCount').textContent='0';
    $('status').textContent='Enable sound';
  } catch (e) {
    console.warn('Default image failed to load:', e);
  }
}

// Load once the DOM is ready
document.addEventListener('DOMContentLoaded', ()=>{
  loadDefaultImage('NGC6543-BYU-L.jpg');
});
</script>
