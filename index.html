<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image Sonifier — Path & Dots → RGB Harmony</title>
<style>
  :root { --b:#e6e6e6; --t:#fff; --mut:#aaa; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  body { 
    margin: 24px; 
    color: var(--t);
    background:#000;
  }  header { margin-bottom: 16px; }
  fieldset { border: 1px solid var(--b); border-radius: 10px; padding: 12px; margin: 0 0 14px; }
  legend { padding: 0 6px; color: #fff; }
  .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
  .col { display:flex; flex-direction:column; gap:8px; }
  label { display:inline-flex; align-items:center; gap:6px; }
  button { padding: 8px 14px; border-radius:10px; border:1px solid var(--b); background:#f8f8f8; cursor:pointer; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .muted { color: var(--mut); }
  .pill { display:inline-block; padding:2px 8px; border:1px solid var(--b); border-radius:999px; background:#fbfbfb; }
  #stage { position: relative; max-width: min(100%, 1100px); border:1px solid var(--b); border-radius:10px; overflow:hidden; }
  #imgCanvas, #drawCanvas { display:block; width:100%; height:auto; }
  #imgCanvas { background:#000; }
  #drawCanvas { position:absolute; left:0; top:0; pointer-events:auto; }
  .badge { font-size:12px; padding:2px 6px; border-radius:6px; background:#aaa; }
  .chip { border:1px dashed var(--b); padding:6px 10px; border-radius:10px; }
</style>
</head>
<body>
<header>
  <h1>Blackbody Harmonization</h1>
  <!-- <div class="muted">Array layout: <span class="pill mono">[R1,G1,B1, R2,G2,B2, …]</span></div> -->
</header>

<fieldset>
  <legend>1) Load image</legend>
  <div class="row">
    <input type="file" id="file" accept="image/*" />
    <div id="imgInfo" class="muted"></div>
  </div>
  <div id="stage" class="col" style="display:none">
    <!-- Image canvas (the pixels you hear) -->
    <canvas id="imgCanvas"></canvas>
    <!-- Drawing overlay (freehand + dots) -->
    <canvas id="drawCanvas"></canvas>
  </div>
  <div class="muted" id="hint">Tip: choose a smaller image (e.g. ≤ 1200px wide) for smoother realtime audio.</div>
</fieldset>

<fieldset>
  <legend>2) Draw path / place dots</legend>
  <div class="row">
    <label><input type="radio" name="tool" value="path" checked> Draw Path</label>
    <label><input type="radio" name="tool" value="dot"> Place Dots</label>
    <span class="chip">Hold <span class="mono">Shift</span> while dragging to erase (path)</span>
  </div>
  <div class="row">
    <button id="clearPath">Clear Path</button>
    <button id="clearDots">Clear Dots</button>
    <label> Path sampling step (px)
      <input id="pathStep" type="number" min="1" max="20" value="2" style="width:60px">
    </label>
    <span class="muted">Playback source:
      <label><input type="radio" name="source" value="path" checked> Path</label>
      <label><input type="radio" name="source" value="dots"> Dots</label>
    </span>
  </div>
</fieldset>

<fieldset>
  <legend>3) Scale & audio</legend>
  <div class="row">
    <label>Key
      <select id="key">
        <option>C</option><option>C#</option><option>D</option><option>D#</option>
        <option>E</option><option>F</option><option>F#</option><option>G</option>
        <option>G#</option><option>A</option><option>A#</option><option>B</option>
      </select>
    </label>
    <label>Scale
      <select id="scale">
        <option value="major">Major</option>
        <option value="natural_minor">Natural minor</option>
        <option value="blues_minor">Blues (minor)</option>
        <option value="pentatonic_major">Pentatonic major</option>
        <option value="pentatonic_minor">Pentatonic minor</option>
        <option value="dorian">Dorian</option>
        <option value="mixolydian">Mixolydian</option>
      </select>
    </label>
    <label>Base octave <input id="baseOct" type="number" min="1" max="7" value="3" style="width:64px"></label>
    <label>Octaves <input id="octaves" type="number" min="1" max="8" value="4" style="width:64px"></label>
  </div>
  <div class="row">
    <label>Pixels/sec <input id="pps" type="range" min="1" max="60" value="3"><span id="ppsVal" class="mono">3</span></label>
    <label>Gain <input id="gain" type="range" min="0" max="1" step="0.01" value="0.25"><span id="gainVal" class="mono">0.25</span></label>
    <label>Per-pixel length (ms) <input id="ms" type="number" min="20" max="800" value="300" style="width:70px"></label>
  </div>
  <div class="row">
    <label>Harmonic mix (per RGB note: 1×/2×/3×)
      <input id="mix1" type="range" min="0" max="1" step="0.01" value="1"><span id="m1" class="mono">1.00</span>
      <input id="mix2" type="range" min="0" max="1" step="0.01" value="0.35"><span id="m2" class="mono">0.35</span>
      <input id="mix3" type="range" min="0" max="1" step="0.01" value="0.2"><span id="m3" class="mono">0.20</span>
    </label>
    <label>Detune RGB (cents)
      <input id="detR" type="number" value="0" style="width:60px">
      <input id="detG" type="number" value="0" style="width:60px">
      <input id="detB" type="number" value="0" style="width:60px">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>4) Convert & Play</legend>
  <div class="row">
    <button id="makeArray" disabled>Convert image → 3×N array</button>
    <button id="play" disabled>Play (follow Path/Dots)</button>
    <button id="stop" disabled>Stop</button>
    <button id="download" disabled>Download array (.json)</button>
  </div>
  <div id="status" class="muted"></div>
</fieldset>

<fieldset>
  <legend>Debug</legend>
  <div class="row">
    <span class="badge">Image: <span id="dim">—</span></span>
    <span class="badge">Array length: <span id="arrLen">—</span></span>
    <span class="badge">Path pts: <span id="pathCount">0</span></span>
    <span class="badge">Dots: <span id="dotCount">0</span></span>
  </div>
  <div class="muted">Preview (first 48): <span class="mono" id="preview">—</span></div>
</fieldset>

<script>
/* ======= DOM helpers ======= */
const $ = id => document.getElementById(id);

/* ======= Canvases and image handling ======= */
const imgCanvas = $('imgCanvas');
const imgCtx = imgCanvas.getContext('2d', { willReadFrequently: true });
const drawCanvas = $('drawCanvas');
const drawCtx = drawCanvas.getContext('2d');

let imgW=0, imgH=0, arrRGB=null;
let imageData=null; // RGBA buffer for pixel reads
let pathPts=[];    // path as array of [x,y] in image pixel coords
let dots=[];       // dots as array of [x,y] in image pixel coords
let drawing=false, lastPt=null, tool='path';

function fitCanvasesToImage(w, h) {
  imgCanvas.width = w; imgCanvas.height = h;
  drawCanvas.width = w; drawCanvas.height = h;
  // CSS makes them fill container; internal size is image pixels so math is simple
}

function getCanvasImageXY(e, canvas) {
  const r = canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  const x = (e.clientX - r.left) * scaleX;
  const y = (e.clientY - r.top) * scaleY;
  // clamp
  return [Math.max(0, Math.min(canvas.width-1, x)), Math.max(0, Math.min(canvas.height-1, y))];
}

function redrawOverlay() {
  drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  // path
  if (pathPts.length > 1) {
    drawCtx.lineWidth = 2;
    drawCtx.strokeStyle = '#00d1ff';
    drawCtx.beginPath();
    drawCtx.moveTo(pathPts[0][0], pathPts[0][1]);
    for (let i=1;i<pathPts.length;i++) drawCtx.lineTo(pathPts[i][0], pathPts[i][1]);
    drawCtx.stroke();
  }
  // dots
  drawCtx.fillStyle = '#ff4d4f';
  dots.forEach(([x,y])=>{
    drawCtx.beginPath();
    drawCtx.arc(x, y, 4, 0, Math.PI*2);
    drawCtx.fill();
  });
}

/* ======= File input / image load ======= */
$('file').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  const img = new Image();
  img.src = URL.createObjectURL(f);
  await img.decode();
  imgW = img.naturalWidth; imgH = img.naturalHeight;
  fitCanvasesToImage(imgW, imgH);
  imgCtx.drawImage(img, 0, 0, imgW, imgH);
  imageData = imgCtx.getImageData(0,0,imgW,imgH); // cache
  $('imgInfo').textContent = `Loaded: ${f.name}`;
  $('dim').textContent = `${imgW}×${imgH}px`;
  $('makeArray').disabled = false;
  $('play').disabled = false; // path/dots mode doesn't require full array, we read on the fly
  $('download').disabled = true;
  $('stage').style.display = 'block';
  pathPts = []; dots = []; redrawOverlay();
  $('pathCount').textContent = '0';
  $('dotCount').textContent = '0';
  $('status').textContent = '';
});

/* ======= Draw tools ======= */
document.querySelectorAll('input[name="tool"]').forEach(r => {
  r.addEventListener('change', () => tool = r.value);
});

drawCanvas.addEventListener('pointerdown', e=>{
  if (!imgW) return;
  drawCanvas.setPointerCapture(e.pointerId);
  const [x,y] = getCanvasImageXY(e, drawCanvas);
  if (tool === 'path') {
    drawing = true;
    lastPt = [x,y];
    pathPts.push([x,y]);
    $('pathCount').textContent = String(pathPts.length);
    redrawOverlay();
  } else { // dot
    dots.push([x,y]);
    $('dotCount').textContent = String(dots.length);
    redrawOverlay();
  }
});

drawCanvas.addEventListener('pointermove', e=>{
  if (!drawing || tool!=='path') return;
  const [x,y] = getCanvasImageXY(e, drawCanvas);
  const step = Number($('pathStep').value)||2;
  // interpolate points to approx step spacing
  const [lx,ly] = lastPt;
  const dx = x - lx, dy = y - ly;
  const dist = Math.hypot(dx, dy);
  if (dist >= step) {
    const n = Math.floor(dist / step);
    for (let i=1;i<=n;i++) {
      const px = lx + dx * (i/n);
      const py = ly + dy * (i/n);
      pathPts.push([px,py]);
    }
    lastPt = [x,y];
    $('pathCount').textContent = String(pathPts.length);
    redrawOverlay();
  }
});

drawCanvas.addEventListener('pointerup', e=>{
  drawCanvas.releasePointerCapture?.(e.pointerId);
  drawing = false; lastPt = null;
});

drawCanvas.addEventListener('pointercancel', ()=>{ drawing=false; lastPt=null; });

/* Erase with Shift+drag (path) */
drawCanvas.addEventListener('pointermove', e=>{
  if (!imgW) return;
  if (e.shiftKey && tool==='path') {
    const [x,y] = getCanvasImageXY(e, drawCanvas);
    // remove path points near cursor
    const rad = 8;
    pathPts = pathPts.filter(([px,py]) => Math.hypot(px-x, py-y) > rad);
    $('pathCount').textContent = String(pathPts.length);
    redrawOverlay();
  }
});

/* Clear buttons */
$('clearPath').addEventListener('click', ()=>{
  pathPts = []; $('pathCount').textContent='0'; redrawOverlay();
});
$('clearDots').addEventListener('click', ()=>{
  dots = []; $('dotCount').textContent='0'; redrawOverlay();
});

/* ======= Make 3×N interleaved array (full image) ======= */
$('makeArray').addEventListener('click', ()=>{
  if (!imgW) return;
  const data = imageData.data; // RGBA
  const N = imgW*imgH;
  const out = new Uint8Array(3*N);
  let k=0;
  for (let i=0;i<data.length;i+=4){
    out[k++]=data[i+0];
    out[k++]=data[i+1];
    out[k++]=data[i+2];
  }
  arrRGB = out;
  $('arrLen').textContent = `${out.length} (3 × ${N} pixels)`;
  $('preview').textContent = Array.from(out.slice(0,48)).join(', ');
  $('download').disabled = false;
  $('status').textContent = 'Full 3×N array ready (optional for export).';
});

/* Download */
$('download').addEventListener('click', ()=>{
  if (!arrRGB) return;
  const blob=new Blob([JSON.stringify(Array.from(arrRGB))],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='rgb_array_3xN.json'; a.click();
});

/* ======= Scale → MIDI mapping ======= */
const ROOTS = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
const SCALES = {
  major:[0,2,4,5,7,9,11],
  natural_minor:[0,2,3,5,7,8,10],
  dorian:[0,2,3,5,7,9,10],
  mixolydian:[0,2,4,5,7,9,10],
  pentatonic_major:[0,2,4,7,9],
  pentatonic_minor:[0,3,5,7,10],
  blues_minor:[0,3,5,6,7,10]
};
function buildScaleMidi(rootName, scaleName, baseOct=3, octaves=4){
  const root=ROOTS[rootName]??0, deg=SCALES[scaleName]??SCALES.major;
  const notes=[];
  for(let o=0;o<octaves;o++){
    const base=(baseOct+o)*12;
    for(const d of deg) notes.push(base+root+d);
  }
  return notes;
}
function valueToMidi(v, list){
  const idx = Math.floor((v/256)*list.length);
  return list[Math.min(idx, list.length-1)];
}
const midiToFreq = m => 440*Math.pow(2,(m-69)/12);

/* ======= WebAudio player (pixel → triad) ======= */
const ppsEl=$('pps'), ppsVal=$('ppsVal'); ppsEl.oninput=()=>ppsVal.textContent=ppsEl.value;
const gainEl=$('gain'), gainVal=$('gainVal'); gainEl.oninput=()=>gainVal.textContent=(+gainEl.value).toFixed(2);
const mix1=$('mix1'), mix2=$('mix2'), mix3=$('mix3');
const m1=$('m1'), m2=$('m2'), m3=$('m3');
[mix1,mix2,mix3].forEach(sl=>sl.addEventListener('input',()=>{
  m1.textContent=(+mix1.value).toFixed(2);
  m2.textContent=(+mix2.value).toFixed(2);
  m3.textContent=(+mix3.value).toFixed(2);
}));

let ac=null, master=null, playing=false, timer=null, seq=[], seqIdx=0;
function ensureAudio(){
  if(!ac){
    ac = new (window.AudioContext||window.webkitAudioContext)();
    master = ac.createGain();
    master.gain.value = +gainEl.value;
    master.connect(ac.destination);
  }
}
gainEl.addEventListener('input', ()=>{ if(master) master.gain.value=+gainEl.value; });

function getRGBat(x, y){
  const ix = Math.max(0, Math.min(imgW-1, Math.round(x)));
  const iy = Math.max(0, Math.min(imgH-1, Math.round(y)));
  const idx = (iy*imgW + ix)*4;
  const d = imageData.data;
  return [d[idx], d[idx+1], d[idx+2]]; // R,G,B
}

/* Build sequence from current source (path or dots) */
function buildSequence(){
  const source = document.querySelector('input[name="source"]:checked').value;
  if (source === 'path') {
    return pathPts.slice(); // as-is order
  } else {
    return dots.slice(); // click order
  }
}

/* Visual cursor while playing */
function drawCursor(pt){
  redrawOverlay();
  if (!pt) return;
  drawCtx.strokeStyle='#ffd400';
  drawCtx.lineWidth=2;
  drawCtx.beginPath();
  drawCtx.arc(pt[0], pt[1], 8, 0, Math.PI*2);
  drawCtx.stroke();
}

/* Schedule one pixel chord */
function schedulePixelChord(time, r,g,b, midiList, noteDur, dets, mix){
  const mids=[valueToMidi(r,midiList), valueToMidi(g,midiList), valueToMidi(b,midiList)];
  const env=ac.createGain();
  env.gain.setValueAtTime(0, time);
  env.gain.linearRampToValueAtTime(1, time+0.01);
  env.gain.exponentialRampToValueAtTime(0.001, time+noteDur);
  env.connect(master);
  mids.forEach((m,i)=>{
    const baseF=midiToFreq(m);
    const parts=[[1,+mix1.value],[2,+mix2.value],[3,+mix3.value]].filter(([mul,gain])=>gain>0 && baseF*mul<ac.sampleRate/2-100);
    parts.forEach(([mul,gain])=>{
      const osc=ac.createOscillator();
      osc.type='sine';
      osc.frequency.setValueAtTime(baseF*mul, time);
      osc.detune.setValueAtTime(dets[i]||0, time);
      const gNode=ac.createGain(); gNode.gain.value=gain;
      osc.connect(gNode).connect(env);
      osc.start(time); osc.stop(time+noteDur+0.02);
    });
  });
}

/* Play control */
$('play').addEventListener('click', async ()=>{
  if (!imgW) return;
  const srcSeq = buildSequence();
  if (srcSeq.length === 0) {
    $('status').textContent = 'Draw a path or add dots first (or switch source).';
    return;
  }
  ensureAudio(); await ac.resume();
  playing=true; seqIdx=0; seq=srcSeq;
  $('stop').disabled=false; $('play').disabled=true;
  $('status').textContent='Playing…';

  const key=$('key').value, scale=$('scale').value;
  const baseOct=parseInt($('baseOct').value||'3',10);
  const octaves=parseInt($('octaves').value||'4',10);
  const midiList=buildScaleMidi(key, scale, baseOct, octaves);

  const pps=parseInt($('pps').value,10);
  const stepSec=1/pps;
  const noteMs=Math.max(20, Math.min(800, parseInt($('ms').value||'120',10)));
  const noteDur=Math.min(stepSec*0.95, noteMs/1000);
  const dets=[parseFloat($('detR').value||'0'), parseFloat($('detG').value||'0'), parseFloat($('detB').value||'0')];

  const lookahead=0.1, ahead=0.25;
  let nextTime = ac.currentTime + 0.05;

  function loop(){
    if (!playing) return;
    while (nextTime < ac.currentTime + ahead) {
      if (seqIdx >= seq.length) { stopPlayback(); return; }
      const [x,y] = seq[seqIdx];
      const [r,g,b] = getRGBat(x,y);
      schedulePixelChord(nextTime, r,g,b, midiList, noteDur, dets, {h1:+mix1.value,h2:+mix2.value,h3:+mix3.value});
      // draw cursor shortly before scheduled time (best-effort)
      drawCursor([x,y]);
      seqIdx++;
      nextTime += stepSec;
    }
    timer = setTimeout(loop, lookahead*1000);
  }
  loop();
});

function stopPlayback(){
  if(!playing) return;
  playing=false; if(timer) clearTimeout(timer);
  $('status').textContent='Stopped.'; $('play').disabled=false; $('stop').disabled=true;
  drawCursor(null);
}
$('stop').addEventListener('click', stopPlayback);
</script>
</body>
</html>
